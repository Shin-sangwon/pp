# TCP/IP의 데이터를 전기 신호로 만들어 보낸다
## STORY1 : 소켓을 작성한다
### 1. 프로토콜 스택의 내부 구성
이 장에서는 네트워크 제어용 소프트웨어(**프로토콜 스택**)와 네트워크용 하드웨어(**LAN 어댑터**) 에 대해서 학습할 것임.  
프로토콜 스택은 크게 TCP, UDP, IP 프로토콜로 구성되어 있다. TCP/UDP는 데이터 송수신, IP는 패킷 송수신을 담당함.  
TCP : 브라우저나 메일 등의 일반적인 에플리케이션 (UDP에 비해 신뢰성 높고 속도 느림)
UDP : DNS 서버에 대한 조회 등에서 짧은 제어용 데이터를 송수신 (TCP에 비해 신뢰성 낮고 속도 빠름)  
IP : 패킷(분할된 데이터 덩어리) 송수신 동작을 제어함. ICMP(패킷 운반 시 발생하는 오류 통지 및 제어용 메세지 통지)와 ARP(IP 주소에 대응하는 이더넷의 MAC 주소 조사) 등으로 동작함.  
LAN 드라이버는 LAN 어댑터의 하드웨어를 제어하고, LAN 어댑터가 실제 송수신 동작(케이블 신호 송수신)을 실행함.  

### 2. 소켓의 실체는 통신 제어용 제어 정보
**프로토콜 스택**은 내부에 제어 정보를 기록하는 메모리 영역을 가지고 있으며, 여기에 통신 동작을 제어하기 위한 제어 정보를 기록함.  
제어 정보의 예는 상대의 IP 주소, 포트 번호, 통신 동작이 어떤 진행 상태에 있는 가 등임.  
본래 소켓은 개념적인 것이어서 실체가 없으므로, 이러한 제어 정보가 소켓의 실체라고 할 수 있음.  
<br>
프로토콜 스택은 이 제어 정보를 참조하면서 동작한다. --> 상대 측의 포트 번호와 같은 제어 정보를 기반으로 데이터를 송수신함.  
데이터가 정상적으로 송신 되어서 수신 측에서 받았는지에 대한 경과 여부, 시간 등도 모두 제어 정보에 기록되어 있음.  
이 뿐만 아니라 다양한 역할을 한다.  
<br>
`netstat` 명령어로 실제 소켓 정보를 확인해볼 수 있음. 이 표시의 한 행이 하나의 소켓에 해당함.  
소켓을 만든다는 동작은, 여기에 새로 한 행의 제어 정보를 추가하고 '여기부터 통신을 시작하는 곳' 이라는 식으로 상태를 기록하는 등 통신을 준비하는 작업임.  
Local과 Foreign이 둘 다 0.0.0.0으로 표시되는 경우는, 아직 통신이 시작되지 않아 IP 주소가 결정되지 않은 것임.  
`PID` 는 Process ID의 약자로, 각 프로그램을 식별하기 위해 OS가 할당하는 번호.  

### 3. Socket을 호출했을 때의 동작
애플리케이션이 socket을 호출하여 소켓을 만들 것을 의뢰하면 프로토콜 스택은 의뢰에 따라 한 개의 소켓을 만듦.  
1. 프로토콜 스택은 이 때, 소켓 한 개 분량의 메모리 영역을 확보함
2. 초기 상태임을 나타내는 제어 정보를 소켓의 메모리 영역에 기록함
3. 소켓을 나타내는 **디스크립터**를 애플리케이션에 알려줌
4. 애플리케이션은 이후 프로토콜 스택에 데이터 송수신 동작을 의뢰할 때 디스크립터를 통지함 (소켓에는 제어 정보가 기록되어 있으므로, 디스크립터만 알고 있으면 애플리케이션은 그 외의 정보를 알 필요가 없음)  

## STORY2 : 서버에 접속한다
### 1. 접속의 의미
소켓을 만들면 애플리케이션은 `connect`를 호출한다. 그러면 프로토콜 스택은 자기쪽의 소켓을 서버측 소켓에 접속한다.  
하지만, 소켓을 만든 직후에 애플리케이션에서 데이터 송신 의뢰가 온다면 프로토콜 스택은?  
소켓을 만든 직후는 아무 것도 기록되어 있지 않으므로 통신 상대가 누구인지도 모른다. 그러므로 서버의 IP주소나 포트 번호를 프로토콜 스택에 알리는 동작이 필요한데, 이것이 접속 동작의 한 가지 역할이다.
이러한 경우, 서버 측에서도 정보가 없으므로 클라이언트 측에서 통신하려는 클라이언트가 있다는 것을 서버 측에 전달해야 한다.  
즉, **접속 동작의 첫 번째 동작은 통신 상대와의 사이에 제어 정보를 주고받아 소켓에 필요한 정보를 기록하고 데이터 송수신이 가능한 상태로 만드는 것이다**.  
데이터 송수신 동작을 실행할 때는 송수신 데이터를 일시적으로 저장하는 메모리 영역이 필요하므로 이 메모리 공간을 확보하는 작업도 이루어지고, 이를 버퍼 메모리 라고 한다.  

### 2. 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다

제어 정보는 크게 두 가지로 나눌 수 있는데, 그 중 한가지는 클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 제어 정보임.  
이것은 접속 동작뿐만 아니라 데이터를 송수신 하는 동작이나 연결을 끊는 동작도 포함하여 통신 동작 전체에서 어떤 정보가 필요한지 검토하여 내용을 TCP 프로토콜의 사양으로 규정하고 있음.  
여러 단계를 거치면서 제어 정보가 부가되는데, 접속 동작의 단계에서는 데이터 송수신이 이루어져 있지 않으므로 데이터가 없고 패킷은 제어 정보만으로 이루어져 있음.  
이 제어 정보를 패킷의 맨 앞부분에 배치하는 곳 부터 **헤더**라고 부름. 헤더는 여러 곳에서 사용되는 용어이므로 TCP 헤더, 이더넷 헤더, IP 헤더와 같이 무엇의 헤더인지를 알 수 있게 작성해야 함.  
클라이언트와 서버는 이 헤더에 데이터 송수신 진행 상황 (통신 개시, 송수신 여부, 통신 종료) 을 저장하므로, 헤더는 매우 중요한 개념임.  
<br>
소켓의 제어 정보는 프로토콜 스택의 프로그램과 일체화 되어 있을 정도로 결합도가 높음.  
소켓에 기록한 제어 정보는 상대측에서 볼 수 없고, 프로토콜 스택을 만드는 사람에 따라서 달라질 수 있음.

### 3. 접속 동작의 실체 



