### TCP/IP의 개념
데이터가 의도된 목적지에 닿을 수 있도록 보장해주는 통신 프로토콜.
### TCP/IP
TCP/IP는 **서브넷**이라는 작은 네트워크를 **라우터**로 접속하여 전체 네트워크가 만들어지는 것이라고 생각할 수 있음.  
서브넷 -> 여러 PC가 하나의 허브에 연결되어 있는 단위  
라우터 -> 패킷을 중계하는 장치의 일종  
허브 -> 패킷을 중계하는 장치의 일종  
여기에 'XX동 XX번지' 라는 형태로 네트워크의 주소를 할당한다. 동에 해당하는 번호 -> 서브넷에 할당, 번지에 해당하는 번호 -> 컴퓨터에 할당  
동에 해당하는 번호를 **네트워크 번호**라 하고, 번지에 해당하는 번호를 **호스트 번호**라 하며 이 두 주소를 합쳐서 IP 주소라고 한다.  
라우터가 주소를 보고 이것이 어느 방향에 있는지를 조사하여 그 방향으로 데이터를 중계하는데, 이 중계 동작을 반복하면 애겟스 대상에 데이터가 도착함.  
**요약**  
송신측이 메세지를 보냄 -> 서브넷 안에 있는 허브가 운반(패킷 형태) -> 송신측에서 가장 가까운 라우터까지 도착 -> 이 과정을 반복하여 최종적으로 도착  

### TCP(Transmission Control Protocol)
인터넷 상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜  
- 패킷을 전송하기 위한 논리적 경로를 배정하는 **연결 지향 방식**이다.
- 3-way handshaking과정을 통해 연결 설정, 4-way handshaking을 통해 연결 해제
- 높은 신뢰성 보장, UDP에 비해 느린 속도

### IP(Internet Protocol)
IP는 Internet Protocol의 줄임말로, 인터넷에서 컴퓨터의 위치를 찾아서 데이터를 전송하기 위해 지켜야 할 프로토콜.
- 32비트의 디지털 데이터
- 8비트(1바이트)씩 점으로 구분하여 10진수로 표기
- 위의 것 만으로는 어느 부분이 네트워크 번호인지 호스트 번호인지 알 수 없음. 단순히 네트워크 번호와 호스트 번호 두 가지를 합쳐서 32비트로 한다는 것만 결정되어 있기 때문
- 그러므로 이 내역을 나타내는 정보를 필요에 따라 IP주소에 덧붙임 --> 이 정보를 '넷마스크' 라고 함
- 넷 마스크 번호도 32비트 부분의 디지털 데이터, 왼쪽에 1이 나열되고 오른쪽에 0이 나열된 값
- 넷마스크가 1인 부분은 네트워크 번호, 0인 부분은 호스트 번호
- 이렇게 표기하면 너무 길어지므로, 한 부분의 비트 수를 10진수로 나타내고 IP주소에 오른쪽에 병기할 수도 있음. EX) 10.11.12.0/24
- 호스트 번호가 모두 0이거나 1인 경우는 특별한 의미이다. 모두 0 : 서브넷 자체, 모두 1 : 서브넷 기기 전체에 패킷을 보내는 '브로드캐스트'를 나타냄  

### UDP(User Datagram Protocol)
데이터를 데이터그램 단위로 처리하는 프로토콜  
TCP와 다르게 연결을 위해 논리적인 경로가 할당되지 않는 **비연결형 프로토콜** 이다. 따라서 각각의 패킷은 다른 경로로 전송되고 독립적인 관계를 가진다.
- 정보를 보내거나 받는다는 신호절차 없음
- 따라서, 신뢰성이 낮지만 TCP에 비해 속도가 빠름
- 연결(connect) 자체가 없으므로 서버 소켓과 클라이언트 소켓의 구분이 없음
- 흐름제어가 존재하지 않음
- 성능이 우선시 되는 경우에 사용

### 흐름제어, 혼잡제어
흐름제어 : 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것.  
혼잡제어 : 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것.

### TCP와 UDP의 헤더 차이
우선, 앞에서 언급한 것 처럼 UDP는 신뢰성이 보장되지 않는 통신이므로 TCP에 비해 헤더가 간단하다.  
**UDP 헤더 구성**
- Source Port(2)
- Destination Port(2)
- Length(2) [전체 헤더의 크기]
- Checksum(2) [중복 검사용, 검증을 위해 전송 단위 내의 비트 수를 센 것]
- Data(65535 - 8(UDP 헤더 길이) - 20 (IP 헤더)) [이 크기가 넘으면 나눠서 보냄]

**TCP 헤더 구성**
- Source Port(2)
- Destination Port(2)
- Sequence Number(4) []
- ACK Number(4) [응답 메세지]
- Checksum(2) [중복 검사용, 검증을 위해 전송 단위 내의 비트 수를 센 것]
- window(2) [TCP 버퍼의 남은 공간]
- flag(2)
- urgent pointer(2)
- data()

### TCP 3 Way-Handshake & 4 Way-Handshake
**TCP Header flag bit**
위의 과정을 이해하기 위해 flag bit에 대해서 자세히 알아보자.

TCP 헤더의 Flag 비트는 TCP 세션의 상태를 제어하는데 중요한 역할을 한다.

TCP Flag 비트는 TCP 헤더의 13번째 바이트부터 시작하는 6개의 비트로 구성되어 있다. 이 Flag 비트는 6가지 상태 중 하나를 나타내며, 각각의 비트는 다음과 같은 의미를 가지고 있다.

1. URG (URGent)
긴급한 데이터가 포함되어 있음을 나타내는 비트이다.
URG 비트가 1인 경우, TCP 세션의 긴급한 데이터가 있음을 의미하며, 긴급한 데이터의 시작 위치를 나타내는 포인터 필드도 함께 전송된다.
2. ACK (ACKnowledge)
수신한 패킷에 대한 ACK (응답)를 보내는 비트이다.
ACK 비트가 1인 경우, 세그먼트에 포함된 데이터가 정상적으로 수신되었음을 의미하며, ACK 번호 필드에 수신한 데이터의 마지막 번호를 포함시켜 전송한다.
3. PSH (PuSH)
버퍼링된 데이터를 바로 전송하도록 강제하는 비트이다.
PSH 비트가 1인 경우, 전송할 데이터가 쌓인 버퍼를 비워 전송하도록 강제한다.
4. RST (ReSeT)
TCP 세션을 종료하고 재설정하는 비트이다.
RST 비트가 1인 경우, TCP 세션을 즉시 종료하고 초기 상태로 재설정한다.
5. SYN (SYNchronize)
TCP 세션을 설정한 후, 서버에서 클라이언트로 응답하는 패킷이다.
SYN 비트가 1인 경우, 새로운 TCP 세션을 설정하고 SYN 번호 필드에 초기 시퀀스 번호를 전송한다.
6. FIN (FINish)
TCP 세션을 종료하는 비트이다.
FIN 비트가 1인 경우, TCP 세션을 종료하고 나머지 데이터를 전송한다.


**3 Way-Handshake**  
TCP 통신 과정에서 데이터를 전송하기 위해서는 먼저 연결상태 -> 가상의 통신로를 확보해야 함.  
이 가상의 통신로를 확보하기 위해서 3 Way-Handshake를 거치게 됨.
A와 B가 연결하려는 과정을 예시로 설명  
1. 먼저, 통신을 하기 위해서 A가 B에게 통신을 하기 위한 '연결' 확립을 해달라고 요청(Syn)함.
 --> 이때, SYN 비트가 활성화되어 1로 바뀐 세그먼트를 전송함
2. 그럼 B는 A가 보낸 요청을 받은 후 응답을 회신하기 위해 연결 확립에 대한 응답(ACK)를 보낸다. 동시에 B도 A에게 데이터 전송에 대한 허가를 받기 위해 연결을 확립해달라고 요청(Syn)한다.
 --> 이때, ACK 비트와 SYN 비트가 1로 활성이 된 세그먼트를 전송함
3. B의 요청을 받은 A도 연결 확립에 대한 응답(ACK)을 함.
 --> 이때, ACK 비트가 1로 활성화된 세그먼트를 전송함   
이와 같이, TCP는 연결을 확립하기 위해 패킷 요청을 세 번 교환하는 과정을 거치는데 이를 3 Way-Handshake라고 부른다.

**4 Way-Handshake**
연결을 확립할 때는 3 Way-Handshake의 과정을 거친다면, 연결을 종료할 시에는 4 Way-Handshake 과정을 거침.  
TCP는 연결을 종료할때도 확인 과정을 거치는데, 연결을 종료할때는 FIN 비트와 ACK 비트를 사용한다.  
1. A는 B에게 연결 종료(FIN)을 요청함.  
  --> 이 때 FIN이 1로 활성화된 세그먼트를 전송함.
2. B는 A에게 연결 종료에 대한 응답(ACK)을 반환함.
  --> 이 때 ACK가 1로 활성화된 세그먼트를 전송함.  
3. 또 B도 A에게 연결 종료 요청(FIN)을 요청함.
  --> 이 때 FIN이 1로 활성화된 세그먼트를 전송함.
4. A도 B에게 연결 종료에 대한 응답(ACK)을 반환함.
  --> 이 때 ACK가 1로 활성화된 세그먼트를 전송함.  
이와 같이 TCP는 세션 연결 확립 후 종료하기 위해 패킷 요청을 네 번 교환하는 과정을 거치는데 이를 4 Way-Handshake라고 부른다.

### 그렇다면, 왜 연결 확립과 종료는 3단계와 4단계로 차이가 발생할까?
간단하게 말하면 TCP 연결 종료 과정에서는 클라이언트와 서버 양쪽에서 보내야 할 데이터가 다 전송 되었는지 서로 알지 못하기 때문이다.  
서버와 클라이언트 중 보내야 하는 데이터가 남아있는 경우에는 FIN 패킷을 받았다는 것을 ACK로 응답하고, 이 때 각자가 보내야 하는 데이터를 모두 전송한 후 자신의 FIN을 보내는 과정 때문에  
연결때와 다르게 한 단계를 더 거쳐야 한다.